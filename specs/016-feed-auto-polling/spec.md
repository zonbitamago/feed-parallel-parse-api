# Feature Specification: フィード自動ポーリング機能

**Feature Branch**: `016-feed-auto-polling`
**Created**: 2025-11-03
**Status**: Draft
**Input**: User description: "10分に1度のポーリング機能を実装する。ポーリングは10分に1度実行し、新しい記事があった場合に即時反映するのではなく、ユーザーの動作（「読み込む」ボタンを押すなど）によって反映する形とする。"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - バックグラウンドで新着記事を自動検出 (Priority: P1)

RSSリーダーユーザーとして、アプリを開いたままにしている間、10分ごとに自動的に新着記事をチェックして欲しい。新しい記事があることを通知で知らせて欲しいが、読んでいる記事が突然入れ替わることは避けたい。

**Why this priority**: この機能のコア価値。ユーザーが手動で更新ボタンを押さなくても、バックグラウンドで自動的に新着を検出できるため、情報の鮮度が保たれる。ただし、即座に反映しないことで、ユーザーの閲覧体験を妨げない。

**Independent Test**: アプリを開いて10分間放置し、購読フィードに新しい記事を追加する。10分後に新着通知が表示されることで独立してテスト可能。既存の手動更新機能に影響を与えない。

**Acceptance Scenarios**:

1. **Given** ユーザーがRSSリーダーを開いており、購読フィードが3件ある、**When** 10分が経過する、**Then** システムは自動的に3件のフィードを取得し、新着記事を検出する
2. **Given** ポーリングで5件の新着記事が検出された、**When** ポーリングが完了する、**Then** ユーザーに「新着記事があります（5件）」という通知が表示される
3. **Given** ポーリングで新着記事が検出されなかった、**When** ポーリングが完了する、**Then** 通知は表示されず、記事一覧は変化しない
4. **Given** ユーザーがオフライン状態である、**When** 10分が経過する、**Then** ポーリングは実行されず、オンラインに復帰した時点で次回のポーリングが再開される

---

### User Story 2 - 新着記事を手動で反映 (Priority: P1)

RSSリーダーユーザーとして、新着記事があることを通知で知った後、読みたいタイミングで「読み込む」ボタンをクリックして、記事一覧に新着記事を表示したい。

**Why this priority**: P1のコア機能と連携して価値を提供。通知だけでは意味がなく、ユーザーが新着記事を実際に閲覧できることが必須。ユーザーの明示的なアクションで反映することで、閲覧中の記事が突然消える問題を回避する。

**Independent Test**: 新着通知が表示されている状態で「読み込む」ボタンをクリックし、記事一覧に新着記事が追加されることで独立してテスト可能。ポーリング機能なしでも、手動で新着記事データを注入すればテストできる。

**Acceptance Scenarios**:

1. **Given** 新着記事が5件検出され、通知が表示されている、**When** ユーザーが「読み込む」ボタンをクリックする、**Then** 記事一覧の先頭に5件の新着記事が追加され、通知が消える
2. **Given** 新着記事を読み込んだ後、**When** さらに10分が経過して新しい記事が検出される、**Then** 再び新着通知が表示され、「読み込む」ボタンで追加の新着記事を読み込める
3. **Given** 新着通知が表示されている、**When** ユーザーが手動更新ボタンをクリックする、**Then** 新着記事が即座に反映され、新着通知も消える

---

### User Story 3 - ポーリング状態の可視化 (Priority: P2)

RSSリーダーユーザーとして、最後にいつポーリングが実行されたかを知りたい。また、次回のポーリングまでの残り時間を確認できると安心できる。

**Why this priority**: UXの向上。ユーザーが「本当にポーリングが動いているのか」を確認できることで、信頼性が高まる。ただし、コア機能（P1）が動作していれば、この表示がなくても機能は成立する。

**Independent Test**: UIに「最終取得: 3分前」や「次回取得まで: 7分」といった表示があることで独立してテスト可能。ポーリング機能とは切り離して、静的な時刻表示として実装・テストできる。

**Acceptance Scenarios**:

1. **Given** ポーリングが正常に完了した、**When** UIを確認する、**Then** 「最終取得: [時刻]」が表示される
2. **Given** 次回ポーリングまで7分ある、**When** UIを確認する、**Then** 「次回取得まで: 7分」が表示される
3. **Given** ポーリングがエラーで失敗した、**When** UIを確認する、**Then** 「最終取得: エラー」または「次回取得まで: 7分（前回エラー）」のように状態が表示される

---

### Edge Cases

- **ポーリング中にユーザーが手動更新ボタンを押した場合**: ポーリングは継続し、手動更新と並行して実行される。両方が完了した時点で最新の記事が反映される。
- **10分間のポーリング間隔中にユーザーがブラウザを閉じた場合**: ポーリングタイマーはリセットされる。次回ブラウザを開いた時点で新しいタイマーが開始される。
- **ポーリング実行中にネットワークがオフラインになった場合**: API呼び出しはタイムアウトエラーで失敗するが、次回のポーリング（10分後）で自動的にリトライされる。エラー通知は表示されない（バックグラウンド処理のため）。
- **新着記事が100件以上検出された場合**: すべての新着記事を記事一覧に追加するが、既存の仮想スクロール機能により、パフォーマンスへの影響は最小限に抑えられる。
- **ポーリングで取得した記事が、既に表示中の記事と重複している場合**: 記事IDで重複判定を行い、重複記事は追加しない。

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: システムは、アプリが開かれている間、10分ごとに自動的に購読中の全フィードを取得しなければならない
- **FR-002**: システムは、ポーリングで取得した記事と現在表示中の記事を比較し、新着記事のみを識別しなければならない
- **FR-003**: システムは、新着記事が検出された場合、ユーザーに視覚的な通知（バナー、トースト等）を表示しなければならない
- **FR-004**: 通知には、新着記事の件数を明示しなければならない（例: 「新着記事があります（12件）」）
- **FR-005**: ユーザーは、通知に表示される「読み込む」ボタンをクリックすることで、新着記事を記事一覧に反映できなければならない
- **FR-006**: 新着記事は、記事一覧の先頭に追加され、日付順にソートされなければならない
- **FR-007**: ユーザーが新着記事を読み込んだ後、通知は自動的に消えなければならない
- **FR-008**: システムは、ユーザーがオフライン状態の場合、ポーリングを自動的に停止しなければならない
- **FR-009**: システムは、ユーザーがオンラインに復帰した場合、ポーリングを自動的に再開しなければならない
- **FR-010**: 最終ポーリング時刻は、ブラウザのlocalStorageに保存され、ページリロード後も保持されなければならない
- **FR-011**: ユーザーが手動更新ボタンをクリックした場合、新着記事（未反映のもの）も含めてすべての記事が即座に反映されなければならない
- **FR-012**: システムは、ポーリング実行中にアプリが閉じられた場合、メモリリークを起こさずにクリーンアップしなければならない
- **FR-013**: ポーリングで取得した記事の重複判定は、記事のID（フィードID + 記事URL）を用いて行わなければならない

### Key Entities

- **PollingState（ポーリング状態）**: ポーリング機能の現在の状態を表す
  - pendingArticles: ポーリングで取得した新着記事（未反映）
  - lastPolledAt: 最終ポーリング時刻（UNIX timestamp）
  - newArticlesCount: 新着記事件数
  - hasNewArticles: 新着記事があるかどうかのフラグ

- **PollingConfig（ポーリング設定）**: ポーリング機能の設定
  - interval: ポーリング間隔（ミリ秒、デフォルト: 600000 = 10分）
  - enabled: ポーリング有効化フラグ（デフォルト: true）

- **NewArticle（新着記事）**: ポーリングで検出された新しい記事
  - 既存のArticle型と同じ構造
  - 重複判定用のID（feedId + link）

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: ユーザーがアプリを開いている間、10分（±30秒）ごとに自動的にフィードが取得される
- **SC-002**: 新着記事が検出された場合、3秒以内にユーザーに通知が表示される
- **SC-003**: ユーザーが「読み込む」ボタンをクリックしてから1秒以内に、新着記事が記事一覧に反映される
- **SC-004**: オフライン状態でポーリングが停止し、オンライン復帰後10分（±30秒）以内に次回ポーリングが実行される
- **SC-005**: ポーリング機能により、ユーザーが手動更新ボタンを押す頻度が50%減少する
- **SC-006**: ポーリング実行中にアプリを閉じても、メモリリークが発生しない（開発者ツールで検証可能）
- **SC-007**: 100件の購読フィードがある場合でも、ポーリング処理が15秒以内に完了する（既存のAPI呼び出しタイムアウトは10秒）
- **SC-008**: 新着記事の重複が0件（記事IDによる重複判定が100%機能する）

## Assumptions

- ポーリング間隔は10分固定とする。ユーザー設定可能な機能は、後のフェーズで検討する。
- ポーリングは`setInterval`を使用し、Reactのカスタムフックで実装する。Service WorkerのPeriodic Background Sync APIは使用しない（実験的機能のため）。
- 既存の手動更新機能（`useFeedAPI`, `fetchFeeds`）を最大限再利用する。
- ポーリング失敗時は、エラー通知を表示せず、次回のポーリング（10分後）で自動的にリトライする。
- 新着通知のUIは、既存のPWA通知（UpdateNotification, OnlineNotification, OfflineNotification）と統一されたデザインとする。
- ブラウザがバックグラウンドタブになった場合、`setInterval`は1分に1回まで制限されるが、10分間隔なので問題ないと判断する。

## Scope

### In Scope

- 10分ごとの自動フィード取得
- 新着記事の検出と通知表示
- ユーザーアクション（ボタンクリック）による新着記事の反映
- オフライン/オンライン状態に応じたポーリングの自動停止/再開
- 最終ポーリング時刻のlocalStorage保存
- 記事の重複判定

### Out of Scope

- ポーリング間隔のユーザー設定機能（5分、10分、15分等の選択）
- ポーリングのON/OFF切り替え機能
- ブラウザ通知（Notification API）による新着通知
- 次回ポーリングまでのカウントダウン表示
- ポーリング履歴の記録・表示
- 特定フィードのみをポーリング対象にする機能

## Dependencies

- 既存の手動更新機能（`useFeedAPI`, `fetchFeeds`, ArticleContext）
- 既存のネットワーク状態監視機能（`useNetworkStatus`）
- 既存のPWA通知コンポーネント（UpdateNotification, OnlineNotification, OfflineNotification）
- 既存の記事重複判定ロジック（記事ID: `${feedId}-${link}`）
- 既存の仮想スクロール機能（react-window）

## Constraints

- ポーリング間隔は10分固定
- ポーリングはフロントエンド（React）で実装（Service Workerは使用しない）
- 既存のAPI仕様を変更しない（バックエンドの変更は不要）
- 既存のArticleContext, SubscriptionContextを拡張するが、破壊的変更は行わない
- ブラウザのlocalStorage容量制限内に収める（ポーリング設定は数KB程度）
